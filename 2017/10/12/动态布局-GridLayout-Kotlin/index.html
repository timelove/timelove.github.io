<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="每天进步一点！" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="前言:  最近项目中需求到一个功能,就是根据后台传过来的数据，在 Android 上进行一个自定义分屏。分屏区域是不定的,分屏区域的大小更是不定的，唯一定的分屏区域的形状肯定是长方形。那这里就想到如同 Excel 合并单元格的模式来进行动态布局。而由于最近 Kotlin 语言大火，本次直接使用到 Kotlin 语言进行实际开发。 动态GridLayout的具体实现方式一般实现 GridLayout">
<meta property="og:type" content="article">
<meta property="og:title" content="动态布局 GridLayout(Kotlin)">
<meta property="og:url" content="http://chicbian.com/2017/10/12/动态布局-GridLayout-Kotlin/index.html">
<meta property="og:site_name" content="ChicBian的博客">
<meta property="og:description" content="前言:  最近项目中需求到一个功能,就是根据后台传过来的数据，在 Android 上进行一个自定义分屏。分屏区域是不定的,分屏区域的大小更是不定的，唯一定的分屏区域的形状肯定是长方形。那这里就想到如同 Excel 合并单元格的模式来进行动态布局。而由于最近 Kotlin 语言大火，本次直接使用到 Kotlin 语言进行实际开发。 动态GridLayout的具体实现方式一般实现 GridLayout">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/dcc3cfcdgy1fkgdztrfn0j206307hjr5.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/dcc3cfcdgy1fkge5jnxitj20c908jjr7.jpg">
<meta property="og:updated_time" content="2017-10-17T03:25:41.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态布局 GridLayout(Kotlin)">
<meta name="twitter:description" content="前言:  最近项目中需求到一个功能,就是根据后台传过来的数据，在 Android 上进行一个自定义分屏。分屏区域是不定的,分屏区域的大小更是不定的，唯一定的分屏区域的形状肯定是长方形。那这里就想到如同 Excel 合并单元格的模式来进行动态布局。而由于最近 Kotlin 语言大火，本次直接使用到 Kotlin 语言进行实际开发。 动态GridLayout的具体实现方式一般实现 GridLayout">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/dcc3cfcdgy1fkgdztrfn0j206307hjr5.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chicbian.com/2017/10/12/动态布局-GridLayout-Kotlin/"/>





  <title> 动态布局 GridLayout(Kotlin) | ChicBian的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ChicBian的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chicbian.com/2017/10/12/动态布局-GridLayout-Kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chicbian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChicBian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                动态布局 GridLayout(Kotlin)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T15:59:20+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><em>前言</em>:  最近项目中需求到一个功能,就是根据后台传过来的数据，在 Android 上进行一个自定义分屏。分屏区域是不定的,分屏区域的大小更是不定的，唯一定的分屏区域的形状肯定是长方形。那这里就想到如同 Excel 合并单元格的模式来进行动态布局。而由于最近 Kotlin 语言大火，本次直接使用到 Kotlin 语言进行实际开发。</p>
<h3 id="动态GridLayout的具体实现方式"><a href="#动态GridLayout的具体实现方式" class="headerlink" title="动态GridLayout的具体实现方式"></a>动态GridLayout的具体实现方式</h3><p>一般实现 GridLayout 都是在 xml 文件中进行配置,然后在 GridLayout 对里面的子控件一个一个的写。如果用这个来实现一个简单的计算器布局,估计很累。同样在具体需求下面,这样的每个都进行布局重写根本不符合我们所需要的功能。因此博主就想到,能不能让 GridLayout 子布局动态大小，而且还要为每个子布局设置属性等等,想想就头大不是么，相当复杂了可以说。</p>
<p>这里就想到一个好办法,就是把 GridLayout 看做一个田字格画布,比如说 3x4 的画布，那这个画布上面就有 12 个格子。跟表格类似。就跟在 Excel 上合并单元格一样，只要能合并单元格的区域就可以单独作为一个子区域。那这个单独的子区域上面可以防止任何组件，如：TextView,Button,Fragment….只要你能想到的控件,基本都可以放进去,然后实现深一步的业务。</p>
<h3 id="Kotlin-简介"><a href="#Kotlin-简介" class="headerlink" title="Kotlin 简介"></a>Kotlin 简介</h3><p>今天的 Google 大会上，已经正式提出将 Kotlin 语言作为 Android 的开发语言。可以说又是一个 Google 的亲儿子，以后肯定会成为 Android 开发的主流语言。其对于传统语言 Java 的优势这里我就不多累赘了，具体可以看知乎上大神些的回答：<a href="https://www.zhihu.com/question/37288009" target="_blank" rel="external">Kotlin 作为 Android 开发语言相比传统 Java 有什么优势？</a></p>
<p>总得来说，用 Kotlin 来开发就会变的很爽。但是毕竟是一个新出语言，市场上，还没有公司正式用该语言进行具体的开发步骤，基本都是大家进行一些个人开发。毕竟很多国内关于 Kotlin 的社区并不是很完善。</p>
<p>本编将在实际操作的过程中顺便介绍 Kotlin 的简单知识，希望对你有所帮助。如遇到不理解的地方，欢迎 Google ，基本上一个 Stackoverflow 社区可以解决你的一些问题(要是访问慢的话试试科学上网吧)。</p>
<h3 id="GridLayout-具体实现步骤"><a href="#GridLayout-具体实现步骤" class="headerlink" title="GridLayout 具体实现步骤"></a>GridLayout 具体实现步骤</h3><h5 id="1-动态布局设置"><a href="#1-动态布局设置" class="headerlink" title="1.动态布局设置"></a>1.动态布局设置</h5><p>首先我们在布局文件中放入一个 GridLayout 作为主布局，然后在代码中动态设置 GridLayout 的横向纵向数，以及每个格子的控件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">GridLayout</span></span></div><div class="line">       <span class="attr">android:id</span>=<span class="string">"@+id/grid_layout"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">     /&gt;</div></pre></td></tr></table></figure>
<p>然后通过代码获取屏幕的长宽，方便后面动态布局设置长宽属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> height = <span class="number">0</span>   <span class="comment">//屏幕高度</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> width = <span class="number">0</span>   <span class="comment">//屏幕宽度</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> mainX = <span class="number">3</span>       <span class="comment">//x轴格子数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> mainY = <span class="number">4</span>        <span class="comment">//Y轴格子数</span></div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">       <span class="comment">//获取手机屏幕高宽度</span></div><div class="line"><span class="keyword">val</span> wm: WindowManager = <span class="keyword">this</span>.windowManager</div><div class="line">height = wm.defaultDisplay.height</div><div class="line">width = wm.defaultDisplay.width</div><div class="line"></div><div class="line">grid_layout.columnCount = mainX <span class="comment">//设置gridlayout 横向格子</span></div><div class="line">grid_layout.rowCount = mainY   <span class="comment">//设置gridlayout 竖向格子</span></div></pre></td></tr></table></figure>
<p>这里我为了操作方便，是直接把 X 和 Y 轴格子数写死了，就是横向 3 个，竖向 4 个，也就说一共是一个 3 x 4 = 12 的表格。如下图：</p>
<p><img src="https://ws1.sinaimg.cn/large/dcc3cfcdgy1fkgdztrfn0j206307hjr5.jpg" alt="img"></p>
<p>这里我们可以根据坐标，已经占用的横纵两向的格子数来合并这些格子。</p>
<p>在手机上，坐标跟普通坐标系是有点反着的，既手机的左上角是坐标原点处，往下是 Y 轴延伸方向，往左是 X　轴延伸方向。请忽略我这个灵魂画手。</p>
<p><img src="https://ws1.sinaimg.cn/large/dcc3cfcdgy1fkge5jnxitj20c908jjr7.jpg" alt="手机屏幕坐标图"></p>
<p>那么现在我们只需要传入 4 个参数，既坐标点 x,y 以及各占用的格子数 xn，xn，就可以在这个 12 表格的 GridLayout 上面将布局画出来。</p>
<p> 每次都单独取一个布局元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> par = GridLayout.LayoutParams()   <span class="comment">//每个子布局单独获取,并分配区域</span></div></pre></td></tr></table></figure>
<p>分配好这个布局所占用的控件位置，以及占用表格大小</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">par.rowSpec = GridLayout.spec(y <span class="keyword">as</span> <span class="built_in">Int</span>, yn <span class="keyword">as</span> <span class="built_in">Int</span>)</div><div class="line">par.columnSpec = GridLayout.spec(x <span class="keyword">as</span> <span class="built_in">Int</span>, xn <span class="keyword">as</span> <span class="built_in">Int</span>)</div><div class="line"><span class="comment">//根据每个格子占用高宽来计算这个子布局的高宽</span></div><div class="line">par.height = height / mainY * yn</div><div class="line">par.width = width / mainX * xn</div></pre></td></tr></table></figure>
<p>如果有要在格子间加入线条的需求，可以设置各个子布局间的距离，然后统一设置整个布局背景，就是线条颜色，也可以在子布局中详细设置，这个就见仁见智了。具体需求具体操作。</p>
<p>因为有些格子是靠边的，所以并不需要靠边的一侧空出间隔，所以要进行一个简单的判断。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断子布局的上下左右是否为边界,是,就不留间隔.</span></div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> != y) &#123;</div><div class="line">           par.topMargin = <span class="number">1</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> != x) &#123;</div><div class="line">           par.leftMargin = <span class="number">1</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (mainX != (x + xn)) &#123;</div><div class="line">           par.rightMargin = <span class="number">1</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (mainY != (y + yn)) &#123;</div><div class="line">           par.rightMargin = <span class="number">1</span></div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>接着把设置的布局元素设置为指定的控件，我这里因为功能需要，都统一成 FrameLayout，然后每个 FrameLayout 都设置一个单独的 Fragment ，方便在独立的 Fragment 中进行逻辑处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t.layoutParams = par</div><div class="line"></div><div class="line">grid.addView(t, par)</div></pre></td></tr></table></figure>
<p>这里我们把这个设置子布局的内容，单独设立一个方法，方便之后的使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 设置Fragment组件 跨多少行 跨多少列</div><div class="line">     * 这里不一样的要设置成 Fragment,其他各种组件都可以自己搭配</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> grid grid控件</div><div class="line">     * <span class="doctag">@param</span> t    fragment布局</div><div class="line">     * <span class="doctag">@param</span> x    组件横向轴开始的索引</div><div class="line">     * <span class="doctag">@param</span> y    组件纵向轴开始的索引</div><div class="line">     * <span class="doctag">@param</span> xn   组件横向拉升位置 就是占几列</div><div class="line">     * <span class="doctag">@param</span> yn   组件列向拉升位置</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setSpanRowCol</span><span class="params">(grid: <span class="type">GridLayout</span>, t: <span class="type">FrameLayout</span>, x: <span class="type">Int</span>?, y: <span class="type">Int</span>?, xn: <span class="type">Int</span>?, yn: <span class="type">Int</span>?)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">val</span> par = GridLayout.LayoutParams()   <span class="comment">//每个子布局单独获取,并分配区域</span></div><div class="line"></div><div class="line">        par.rowSpec = GridLayout.spec(y <span class="keyword">as</span> <span class="built_in">Int</span>, yn <span class="keyword">as</span> <span class="built_in">Int</span>)</div><div class="line">        par.columnSpec = GridLayout.spec(x <span class="keyword">as</span> <span class="built_in">Int</span>, xn <span class="keyword">as</span> <span class="built_in">Int</span>)</div><div class="line">        par.height = height / mainY * yn</div><div class="line">        par.width = width / mainX * xn</div><div class="line"></div><div class="line">        <span class="comment">//判断子布局的上下左右是否为边界,是,就不留间隔.</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != y) &#123;</div><div class="line">            par.topMargin = <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != x) &#123;</div><div class="line">            par.leftMargin = <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mainX != (x + xn)) &#123;</div><div class="line">            par.rightMargin = <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mainY != (y + yn)) &#123;</div><div class="line">            par.rightMargin = <span class="number">1</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.layoutParams = par</div><div class="line"></div><div class="line">        grid.addView(t, par)</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到这里基本就是这个动态设置的思路，需要注意的是，每次添加布局，子布局的大小以及位置不能有冲突，不然子布局会重叠，这个需要添加之前就计算好。</p>
<p>我这边自己手动添加了 2  个集合用来 for循环添加子布局。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">listone = ArrayList()</div><div class="line">listone?.add(Data.Single.getInstance(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>))</div><div class="line">listone?.add(Data.Single.getInstance(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</div><div class="line"></div><div class="line">listtwo = ArrayList()</div><div class="line">listtwo?.add(Data.Single.getInstance(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>))</div><div class="line">listtwo?.add(Data.Single.getInstance(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>))</div><div class="line">listtwo?.add(Data.Single.getInstance(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> listone!!.indices) &#123;</div><div class="line">   <span class="keyword">val</span> <span class="keyword">data</span>: Data = listone!!.<span class="keyword">get</span>(i)</div><div class="line"></div><div class="line">   <span class="keyword">val</span> fragmentlayout: FrameLayout = FrameLayout(<span class="keyword">this</span>)</div><div class="line">   fragmentLayouts?.add(fragmentlayout)</div><div class="line">   fragmentlayout.id = View.generateViewId()</div><div class="line">   setSpanRowCol(grid_layout, fragmentlayout, <span class="keyword">data</span>.x, <span class="keyword">data</span>.y, <span class="keyword">data</span>.xn, <span class="keyword">data</span>.yn)</div><div class="line">                         addFragment(EasyFragment.Single.getInstance(i.toString()),  fragmentlayout.id)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>基本到这里整个动态 GridLayout 的添加就算完成了，下面主要介绍下本编中用到的 Kotlin 语言的相关知识。</p>
<h5 id="2-Kotlin-简单语法介绍"><a href="#2-Kotlin-简单语法介绍" class="headerlink" title="2.Kotlin 简单语法介绍"></a>2.Kotlin 简单语法介绍</h5><ol>
<li><p>Kotlin 变量，常量</p>
<p>变量 var，常量 val 表示，这点比 Java 中简洁多了，跟 JavaScript 类似。</p>
</li>
<li><p>Kotlin 数据初始化</p>
<p>Kotlin 中的数据类型跟 java 中类似，基础数据类型都包含有。</p>
<p>而 Kotlin 对于数据或者对象的初始化可以直接通过 ：来代替数据类型，也可以直接用 = 直接表明类型，该类型会直接饮用 = 后面的数据类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> height : <span class="built_in">Int</span>? = <span class="literal">null</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> height = <span class="number">0</span>   <span class="comment">//屏幕高度</span></div></pre></td></tr></table></figure>
</li>
<li><p>Kotlin 空指针</p>
<blockquote>
<p>在Kotlin中空指针异常得到了很好的解决。</p>
<ul>
<li>在类型上的处理，即在类型后面加上?，即表示这个变量或参数以及返回值可以为null，否则不允许为变量参数赋值为null或者返回null</li>
<li>对于一个可能是null的变量或者参数，在调用对象方法或者属性之前，需要加上?，否则编译无法通过。</li>
</ul>
<p>如下面的代码就是Kotlin实现空指针安全的一个例子，而且相对Java实现而言，简直是一行代码搞定的。</p>
</blockquote>
<p>这里不单独对空指针问题进行介绍了，毕竟这个属于学习 Kotlin 中的一个复杂点，关于空指针安全原理，可以参考这篇文章<a href="http://droidyue.com/blog/2017/05/08/how-to-study-kotlin/" target="_blank" rel="external">研究学习 Kotlin 的一些方法</a></p>
</li>
<li><p>Kotlin 的类型转换</p>
<p>在实际项目中会经常遇到数据类型转换问题，在 Kotlin 中，会经常遇到比如 Int? 转化为 Int ，就可以直接用 as 直接转化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y <span class="keyword">as</span> <span class="built_in">Int</span></div></pre></td></tr></table></figure>
<p>这一串代码直接将 y 重新赋值成 Int 类型，相当于java中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y = Integer.valueOf(y)</div></pre></td></tr></table></figure>
<p>简洁明了。当然 Kotlin 也支持多种转化方式，比如toInt，toString等等。</p>
</li>
<li><p>Kotlin 方法类别</p>
<p>代码中直接用 fun 就能表面是一个方法，甚至都不需要 function。</p>
<p>而且直接设置该方法的返回类型，也只需要用 ：来表面，比如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(url: <span class="type">String</span>)</span></span>: String &#123;</div><div class="line">  retrun url</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那这里就必须返回一个 String 类型。</p>
</li>
<li><p>Kotlin 方法扩展</p>
<blockquote>
<p>很多时候，Framework提供给我们的API往往都时比较原子的，调用时需要我们进行组合处理，因为就会产生了一些Util类，一个简单的例子，我们想要更快捷的展示Toast信息，在Java中我们可以这样做。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">public</span> static void longToast(Context context, String message) &#123;</div><div class="line">&gt;    Toast.makeText(context, message,     Toast.LENGTH_LONG).show();</div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>但是Kotlin的实现却让人惊奇，我们只需要重写扩展方法就可以了，比如这个longToast方法扩展到所有的Context对象中，如果不去追根溯源，可能无法区分是Framework提供的还是自行扩展的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="function"><span class="keyword">fun</span> Context.<span class="title">longToast</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</div><div class="line">&gt;    Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_LONG).show()</div><div class="line">&gt;&#125;</div><div class="line">&gt;applicationContext.longToast(<span class="string">"hello world"</span>)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>注意：Kotlin的方法扩展并不是真正修改了对应的类文件，而是在编译器和IDE方面做得处理。使我们看起来像是扩展了方法。</p>
</blockquote>
<p>本次项目中就使用到了该方法，通常在 BaseActivity 中，扩展一些方法比如正常的添加 fragment ，可以直接类似重写一般的扩展:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Fragment 添加</span></div><div class="line">   <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> FragmentManager.<span class="title">inTransaction</span><span class="params">(func:    <span class="type">FragmentTransaction</span>.()</span></span> -&gt; FragmentTransaction) &#123;</div><div class="line">       beginTransaction().func().commit()</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">fun</span> AppCompatActivity.<span class="title">addFragment</span><span class="params">(fragment: <span class="type">Fragment</span>, frameId: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">       supportFragmentManager.inTransaction &#123; add(frameId, fragment) &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> AppCompatActivity.<span class="title">replaceFragment</span><span class="params">(fragment: <span class="type">Fragment</span>, frameId: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">supportFragmentManager.inTransaction &#123; replace(frameId, fragment) &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>​       那我们在之后继承了 BaseActivity 的 Activity 中都可以直接调用 addFragment 和 replaceFragment 方法:</p>
   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addFragment(EasyFragment.Single.getInstance(i.toString()), fragmentlayout.id)</div></pre></td></tr></table></figure>
<ol>
<li><p>Kotlin 单例模式</p>
<p>我们经常要在一些 class 中使用到单例模式，一般好的 java 中都是这么调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> MyPicasso myPicasso;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (myPicasso == <span class="keyword">null</span>)</div><div class="line">		myPicasso = <span class="keyword">new</span> MyPicasso();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyPicasso <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (myPicasso == <span class="keyword">null</span>)</div><div class="line">		createInstance();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> myPicasso;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过一个 synchronized 进行一个异步创建单例，但是这样代码很多了就，而且不方便。但是在 Kotlin 中可以直接一个 Object 解决问题。并且可以在这个 object中进行一些具体操作，很方便。我在一个 Fragment 实现单例，并且可以直接传入参数。相当简洁。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Single &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(str: <span class="type">String</span>)</span></span>: EasyFragment &#123;</div><div class="line">            <span class="keyword">val</span> instance: EasyFragment = EasyFragment()</div><div class="line">            instance.mStr = str</div><div class="line">            <span class="keyword">return</span> instance</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Kotlin 数据序列化</p>
<p>在 java 中一般都要继承 2 个接口 Serializable 或者 Parcelable ，虽然现在有了工具不需要手写 get 和 set，但是代码量在那边摆着呢，显得很麻烦。</p>
<p>而在 Kotlin 中，直接一个 data class 就直接搞定，Kotlin 中自动包含了setter 和 getter。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 数据Model</div><div class="line"> */</div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>, <span class="keyword">val</span> xn: <span class="built_in">Int</span>, <span class="keyword">val</span> yn: <span class="built_in">Int</span>) &#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过本次实际程序，基本可以对 Kotlin 的用法有个基本了解了，有不会的地方大可以直接 Google，国外对于该方面的资料还是比国内多很多。欢迎各位的学习讨论。</p>
<h5 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h5><p>废话不多说，直接上源码：<a href="https://github.com/timelove/GridDemo" target="_blank" rel="external">源码地址</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/14/Django学习一/" rel="next" title="Django学习一">
                <i class="fa fa-chevron-left"></i> Django学习一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/28/5年之痒，再见了LOL/" rel="prev" title="5年之痒，再见了LOL">
                5年之痒，再见了LOL <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


           
     <div class="comments" id="comments">
       
            <div id="uyan_frame"></div>
       
     </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="chicbian" />
          <p class="site-author-name" itemprop="name">chicbian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态GridLayout的具体实现方式"><span class="nav-number">1.</span> <span class="nav-text">动态GridLayout的具体实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin-简介"><span class="nav-number">2.</span> <span class="nav-text">Kotlin 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GridLayout-具体实现步骤"><span class="nav-number">3.</span> <span class="nav-text">GridLayout 具体实现步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-动态布局设置"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.动态布局设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Kotlin-简单语法介绍"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.Kotlin 简单语法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">3.0.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#源码地址"><span class="nav-number">3.0.4.</span> <span class="nav-text">源码地址</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chicbian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  



  




	





  





    
      
    

   
        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2130903"></script>
        <!-- UY END -->
    
  


  




  
  

  

  

  

  


  

</body>
</html>
